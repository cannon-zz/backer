1.100 (2001/1/29)
	*** THIS VERSION INCLUDES AN INCOMPATIBLE TAPE FORMAT CHANGE ***

	New random number generator.

	Fewer parity symbols:  10 & 14 rather than 16 & 20.

	BKRIOCGETSTATUS will now update the DMA buffer offsets if too much
	time has elapsed since the last update.

	Fixed possible sequence glitch:  need_sequence_reset is now
	explicitly set at the start of each transfer.

	Fixed erroneous over-run reporting when an uncorrectable block is
	found.

	Complete overhaul of the block/sector nonsense.  For starters, the
	new tape format elliminates the auxiliary data region.  With that
	gone, the interleave ratio was increased by a factor of two which
	is how the parity symbols could be safely reduced.  Next, the role
	of data randomizing and ECC encoding/decoding was moved to the
	sector layer.  With ECC done at the sector layer, the sector code
	can now insert and retrieve a header which it uses to store a 32
	bit sector number.  This elliminates the need for block sequence
	numbers which shrinks each block header to just 1 byte thus
	increasing the tape capacity even further.  This also allows more
	bits in the block headers to be used to identify the block type
	which might be used to multiplex several data streams together.
	Since, at 32 bits, the sector number takes about 20000 hours to
	loop around, it provides the data stream with an absolute position
	marker.  This means there is now 100% accuracy in the
	identification of buffer overruns.

1.0 (2001/1/13)
	More performance and foot print improvements to the Reed-Solomon
	code.

	Disabled EP mode until I either get it working or drop it
	altogether.

	Finally got MONITOR.EXE (one of the utilities shipped with a
	Backer) to run under dosemu (sort of).  This allowed me to trace
	I/O port activity and see how Danmere controls the card.  I believe
	I now have the correct sequence in which bits are to be set to
	configure the card for a transfer.  Preliminary tests look good as
	I have not been able to produce any of the inconvenient behaviour
	the card had been showing in the past.

	One or two last minute code clean-ups.

	Gave the documentation a going-over.

0.12(beta) (2000/12/11)
	Fixed a bug in the low level write code:  in the event of an error,
	update_device_offset() was still clearing the update interval timer
	which would prevent retrys from actually retrying.  When propogated
	out to the user's world this bug had the effect of occasionally
	defeating the driver's ability to detect a missing video signal.
	The truth is, though, that this should not have actually had any
	effect.  Hmm....

	Hmm is right!  Checking out how this "bug" managed to manifest
	itself has led me to discover new properties of the hardware.  The
	sync bit on the card's I/O port is actually only for the input
	signal.  This is why the card had appeared to me to be unable to
	generate output without a return signal from the VCR.  It turns out
	that the card can indeed generate output without a return signal.
	I won't go into details but what it boils down to is that in fact
	the "bug" was in my misunderstanding of the function of the sync
	bit.  So we're all happy now.  Although it's no longer necessary,
	the driver still demands that a return video signal be present as a
	check of the data path.

	Solidified error reporting.  The driver had been a little relaxed
	about getting error codes out to the kernel in that it was not
	specifically retaining error codes for the purpose of reporting
	them on a retry but was relying on the error recurring on the
	retry.  Only in the case of an uncorrectable data block can the
	error not occur on the retry and it's unlikely for one
	uncorrectable block to be unacompanied so this wasn't really a
	problem.  Anyway, now the driver makes a point of always returning
	the last error code before proceding.

	Code clean ups.

0.11(beta) (2000/11/26)
	Fixed minor bug in the read and write codes:  in the event of an
	error, the wrong count of actual bytes moved was being returned to
	the system.

	Made a few changes to the formating layer's logic to allow
	non-blocking I/O to take place.  Yes, non-blocking I/O is now
	officially a feature of this driver.  Go ahead and use it and
	report any problems.  My own test has been to write a 50 MB file
	and read it back again with O_NONBLOCK set in both directions.  I
	saw 1.6 million EAGAINs while writing it and 2.8 million EAGAINs
	while reading it but the file was recovered perfectly.

	Code clean ups here and there.

0.10(beta) (2000/11/21)
	Performance improvements to the Reed-Solomon encoder and decoder
	but increased footprint.

	Hardware probe is now only done on write transfers because during
	reads the driver can't tell the difference between missing hardware
	and a mere missing video signal.

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Bug fix: BKRIOCGETAUX and BKRIOCSETAUX now return -ENXIO when the
	sector buffer is not properly allocated.

0.9(beta) (2000/11/16)
	Some documentation updates.

	Serious bug fix:  the auxiliary buffer was not pointing to a safe
	region of memory when the driver was put in raw mode.  This could
	crash your system if you attempted to use bkrtest in raw mode
	(which you ARE supposed to be able to do!).

	Serious bug fix:  if the driver could not allocate memory for its
	buffers during the last mode change and you attempted to read from
	or write to the device then bad things would happen.  This is
	fixed.

	Modified access control.  Superusers can still access the device
	regardless of whether or not it is in use but they are now only
	allowed access to ioctl() if a transfer is in progress.  This
	elliminates a "feature" which allowed superusers to terminate
	another user's transfer (probably leading to problems when that
	user themself's subsequently tried to stop it).

	Lots of code clean ups including low-level device I/O, raw mode
	format layer, data randomizer.

	Added check for presence of hardware at the start of a transfer.  I
	know I said the driver was in a "feature freeze" but after the
	clean ups to the low-level I/O code this was so easy to add I just
	had to do it.

0.8(beta) (2000/11/06)
	First beta release.

	Fixed a bug in the read code which was introduced in the last
	version and was preventing it from returning EOF.

0.7 (2000/11/03)
	Re-worked the I/O code's error reporting mechanism.  Save for any
	bugs that might be discovered in this stuff this now completes the
	system friendliness of the driver.

	Implemented the beginings of non-blocking I/O.  It's actually all
	in there but it's completely untested.  Since tar does not make use
	of non-blocking I/O there's no easy way to put this through its
	paces.  I'm going to have to write a test program.

	Fixed bug in overrun checking code:  the subtraction wasn't being
	done modulo the sequence size.  I hope this didn't cause any
	problems for anyone... 'cause it could have :-(.  It was defeating
	the ability of the driver to skip over underflows during playback.

	If an uncorrectable block is encountered, the driver now removes
	the block from the data stream and returns -ENODATA rather than
	silently pretending that nothing's wrong.

	If an error occurs in the data stream while reading then the block
	sequence counter is now reset.  This keeps the quantity of lost
	data to a minimum.

	Some documentation updates and additions.

0.6 (2000/10/30)
	The driver now checks to see if a video signal is present before
	attempting to proceed with a transfer.  This avoids getting the
	system stuck in a busy loop until the driver times out.

	The device level I/O code will now always go to sleep for a 50th of
	a second between buffer updates rather than switching to a busy
	loop after the first two updates fail.  This keeps the driver from
	plugging up the system before actual tape data starts during a read
	and while flushing the buffer after writing.

	Driver now counts buffer overruns on read.

	Another minor performance improvement to the Reed-Solomon decoder.

0.5 (2000/10/25)
	Implemented an internal sector buffer.  Previously sectors were
	processed in place in the DMA buffer.  I had believed this was
	workable but it now seems that this makes the reliable handling of
	overruns too complicated.  Sectors are now processed in a seperate
	buffer which is transfered to/from the DMA buffer as a whole.  This
	extra copying of data introduces a small increase in the processing
	overhead.

	Added mandatory DMA buffer offset updates if a maximum update delay
	has been exceeded.  I hope that between this and the new sector
	buffer we will handle underflows during writing perfectly
	gracefully.  Preliminary tests look great!  I can force horrible
	buffer underflows during writing by using tar to write directly to
	the device while using bzip2 for compression.  By selecting a small
	record size I can generate many frequent underflows and so far I've
	been able to recover the data without any problems (knock on wood).

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Fixed a bug in the fame error checker:  the maximum search length
	allowed when finding the next key neglected to allow for the
	additional line in odd video fields.

	Minor performance enhancement to the Reed-Solomon decoding
	algorithm.

	Assorted code clean ups.

0.4 (2000/10/20)
	Fixed a bug in the sector locator algorithm which could cause the
	decoder to skip ahead of the incoming tape data.

	Fixed an erasure related buffer overflow in the Reed-Solomon
	decoder but it was not affecting this driver since the driver does
	not make use of erasures.

	Removed "feature" which caused reads to not terminate automatically
	if the tape data simply stopped (eg. without a proper EOR mark):
	ETIMEDOUT is now returned from the block layer rather than
	retrying.

	Improved sanity when switching modes.  Although I'd never had
	troubles myself, while checking the code I felt weird things might
	happen under certain read / close / mode change / open
	combinations.  Definitely all perfect now :-).

	Allowed randomizer to handle odd sized blocks by always allocating
	an even number of bytes for the block buffer.  This wasn't an issue
	yet since the blocks in all current formats have an even number of
	bytes in them.

0.3 (2000/10/17)
	Fixed bug in BKRIOCGETFORMAT ioctl which caused the block capacity
	to be reported as the number of data bytes contained in the current
	block rather than as the design capacity of a block.

	Removed memory access priviledge checks from the read() and write()
	methods --- the kernel (in 2.0.36 at least) checks for us.

	Many documentation improvements.

0.2 (2000/10/10)
	First public release.
