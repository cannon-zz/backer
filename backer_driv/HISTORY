2.0 (2001/4/12)
	Changed the flags used to represent the data format to help fix a
	bug in bkrencode.

	Moved the minor numbers around again.  Very sorry!  This was done
	in anticipation of potentially migrating the driver into the main
	kernel tree.  Now each operating mode is assigned a fixed minor
	number --- no more shuffling of minor numbers depending on which
	modes are actually compiled in and which aren't.  If you have been
	using the driver with all modes enabled then you will not see a
	difference.

	Found and fixed a bug in the Makefile's dev target when updating it
	for the new minor numbers.  The modes NTSC/low/raw and NTSC/low/SP
	had their minor numbers backwards.

	If devfs is not in use, the inodes created by the Makefile now have
	the same names as the devfs versions (a tree off /dev).

	Moved more documentation from the postscript file to text files.

	Finally found the cause of the "Unresolved symbol" warnings from
	depmod:  my kernels are compiled with symbol versioning turned on
	so all the symbol names are mangled.  Fixed the problem by
	symbol-versioning the driver.

1.107(beta) (2001/3/24)
	*** INCOMPATIBLE TAPE FORMAT CHANGE ***

	Changed the devfs entry naming scheme.  Rather than dumping
	everything into /dev, a tree structure is created of the form
	/dev/backer/?/??? where the first ? is the device number (currently
	only one device is supported so this is always 0) and the file name
	is three characters:  1st character is n/p for NTSC/PAL, 2nd
	character is h/l for high/low density and last character is e/s/r
	if the file represents an EP/SP/raw mode respectively.  The
	minor-to-mode mapping has also changed.

	Gave the makefile an overhaul:  the install target now checks to
	see if devfs is in use by scanning /proc/mounts and automatically
	creates the device inodes if devfs is not found.

	Re-structured the internal mode flags so that rather than having
	two "formated" modes and one "raw" mode there are three "data
	formats":  sp, ep and raw (pass-through).  This matches the device
	file naming scheme.

	Moved some of the documentation out of the postscript file into
	text files and a man page to be a little more "standard".

	The MTGET ioctl now returns the count of total errors corrected
	since the last read started in the mt_erreg field.

	Adjusted the interleaving and the number of parity symbols in some
	of the tape formats.

	The code is now in feature freeze for 2.0.  Among other things, the
	tape format will not change until the next developmental (pre 3.0)
	series.

1.106 (2001/3/14)
	Fixed bug in transfer start code that would allow a second transfer
	to be started even if one was in progress.

	The "one user only" mechanism has been handed over to devfs's
	internal uid/gid setting feature which means it works a little
	differently:  ownership is done on a device-by-device basis which
	means more than one user can have open devices at a time but all
	except the first will see "Device Busy" if they try to access the
	underlying hardware.

	Removed leader and trailer from bkrformat since nothing's used them
	for a long time.

	High density EP modes will be disabled for version 2.0 and the dev
	target in the makefile has been modified appropriately.  The
	developmental series will retain the EP modes for experimentation,
	however, so the dev target is no longer appropriate for
	developmental versions.

1.105 (2001/3/9)
	*** INCOMPATIBLE FORMAT CHANGE ***

	Added devfs support.

	Added a loop when a read is started to allow the driver to wait as
	long as timeout for a valid sector to appear.  This means that you
	can start reading from the device before the BOR mark is visible on
	your television without getting an I/O error.  The error codes now
	occur as follows:  if no DMA activity is seen before the timeout
	then an I/O error is reported which could mean that you've got the
	driver configured for the wrong DMA channel or that there was no
	video signal on the tape;  if DMA activity is detected but no valid
	data sectors are found before the timeout then a timeout error is
	reported which probably means you've got the right DMA channel but
	the video signal didn't contain anything.

	With the above change in place, I increased the default timeout
	from 10 seconds to 15 seconds to make the driver a little more
	user-friendly.

	Realized that grouping the parity symbols at the end of the sector
	as introduced in 1.104 partially "undid" the interleaving,
	effectively doubling the peak aparent symbol error rate.  The tape
	format has been modified to get the on-tape interleaving back the
	way it used to be.  This is probably the last structural format
	change before 2.0 (but not last parameter change).

	Adjusted the bit allocations in the sector header.

	Rather than falling back to a default mode, open() now fails if the
	minor number is not recognized.

	In raw mode, the transfer unit size is now a full video frame.
	This should improve the throughput since external applications will
	most likely be reading/writing data in quantities commensurate with
	this size.

	Added a fix for a bug in non-comensurate interleaving but it's
	disabled by default to save CPU cycles.

	The usual tweaks here and there.

1.104 (2001/3/4)
	*** INCOMPATIBLE FORMAT CHANGE ***

	read() and write() now lock out other processes to prevent
	re-entrance.

	Separated the device layer code completely from the kernel
	interface.  They're still in one file but share no data.  This was
	done so that bkrencode's source code could be split.

	Cleaned up the sector locator algorithm to work with the new stdio
	device layer for bkrencode.  As a side benefit the compiled code is
	tighter but I'm not sure if the performance has gone up or down.

	Completely new tape format!  There are no longer blocks --- just
	sectors.  This was accomplished by getting the Reed-Solomon
	coder/decoder to handle parity symbols that are stored in a
	separate buffer which allows the formating code to group all the
	parity symbols together in one part of the sector while all the
	data symbols are in another part of the sector.  This removes the
	need to process the sector one block at a time:  all the data
	symbols can be inserted at once, a single sector header added, then
	the parity symbols are computed "block"-by-"block".  The results:
	(i) higher tape capacity (no more block headers);  (ii) longer
	sector key meaning more robust framing;  (iii) less CPU overhead
	due to fewer function calls and loop iterations;  (iv) sector data
	can be selectively randomized meaning we have visual BOR and EOR
	marks again (I've missed these!);  (v) the MTIOCGET reports
	consistent block number and residual counts since these now both
	refer to sectors i.e. the block (sector) number changes every time
	the residual count goes to 0.

	Ported the driver to the 2.4 kernel series which it now requires.
	It might work with 2.2 kernels but if it doesn't then it probably
	wouldn't take much work to get it working.  It will definitely not
	work with 2.0 kernels any more.  There is still no devfs support,
	however.

	Lots of other little changes here and there.

1.103 (2001/2/20)
	*** INCOMPATIBLE FORMAT CHANGE ***

	Changed the leader bytes to 0xe2 like Danmere (maybe they know
	something I don't).

	Fixed a bug in non-comensurate interleaving support:  the driver
	wasn't adjusting the sector header offset for the unused space at
	the start of a sector (no modes use this so it's not an issue).

	Removed block_capacity from bkrformat.  Nothing's used it for
	while.

	Re-allocated bits in the block header structure so that all unused
	bits belong to the block type.  This way future format extensions
	will work with older drivers:  older drivers (from this version on)
	will treat format extensions as unrecognized block types and skip
	them.

	The mt_resid element returned by MTIOCGET now indicates the bytes
	required to fill/empty the current block (it was unused
	previously).

	The operating mode is now selected by the device minor number.
	This means:  (i) there are now 12 requisite entries in the dev
	directory corresponding to the 12 operating modes;  (ii) the
	utility bkrmode no longer exists;  (iii) the config= option has
	been removed with the timeout being set the way it used to be via
	the timeout= option;  (iv) the device is never "not configured"
	since the validity of the operating mode is ensured at the source
	level;  (v) the BKRIOCGETCONFIG and BKRIOCSETCONFIG ioctls are gone
	with the mode now being retrieved only via MTIOCGET (mt_dsreg);
	(vi) adjusting the timeout after module load will have to wait
	until 2.4.x (the required MTSETDRVBUFFER sub-sub-command is not
	present in 2.0.x's mtio.h).

	Fixed another show-stopper pointer initialization bug in
	bkr_format_reset().

1.102 (2001/2/13)
	Formating code now flushes itself after writing an EOR mark.

	The interleave ratio can now be set on a mode-by-mode basis at
	compile time via the format[] parameter array.  Added support for
	non-comensurate interleaving (but it wastes space on the tape so
	it's not recommended).

	Fixed a critical pointer initialization bug in bkr_format_reset()
	and a few other bugs here and there too but can't remember what,
	though.

	Moved the documentation for the utilities into a separate file.

1.101 (2001/2/8)
	This is another major re-write.  Many changes have been made to the
	way the driver interacts with the outside world.

	Implemented a mechanism to delay the start of a data transfer until
	the first I/O operation.

	The delayed start mechanism has removed many race conditions which
	had previously been avoided by imposing unusual access restrictions
	so the entire access control mechanism has been loosened up.  In
	particular:
		-The driver no longer has unusual interpretations of the
		file mode: you can use O_RDONLY/O_WRONLY/O_RDWR as you wish
		and as long as you don't actually call read() or write() no
		transfer will be started (which means the driver now
		behaves itself for mt).
		
		-The device can now be opened multiple times even with a
		direction specified:  the first call to read() or write()
		gives the data stream to that file descriptor and all
		subsequent reads and writes by others fail.
		
		-The device can even be opened by multiple users (but, for
		safety, only if the 2nd and subsequent users are super
		users).
	This should bring the driver's access mechanism in line with
	standard Unix semantics.

	Tracked down and corrected another source of the "start on wrong
	line" syndrom.  It turns out that the card's hardware does not like
	being stopped in the middle of a video frame.  If one takes care to
	always stop writing on a frame boundary then subsequent transfers
	(are more likely to) start on the correct video line.  The fix I
	used was to make bkr_device_flush() fill to a frame boundary before
	flushing the DMA buffer.

	Farther separated the device and formating code.  This has added
	some bloat to the source code but the compiled size has actually
	gone down.  This will increase the ease with which support for the
	external version can be added if I am ever able to get my hands on
	one.

	The mode can now be set at module load time.  It and the timeout
	are now both set with the config= option.  See the docs.

	Obfuscated the Reed-Solomon decoder source code a little with some
	#if-#else-#endif's in order to improve the performace a wee bit
	more.

	Changed the bkrstatus structure.  The "temporary" debuging
	information is now permanent and is grouped together as health
	info.  Anything using BKRIOCGETSTATUS needs to be updated.

	The device layer now monitors the DREQ bit rather than the SYNC
	bit.  This means that the driver no longer cares if a return video
	signal is present (in case you only want to hook up one cable).  It
	also means that stopping a tape while reading from it results in an
	I/O error rather than a timeout.

	Lots of other little touch-ups here and there.

1.100 (2001/1/29)
	*** THIS VERSION INCLUDES AN INCOMPATIBLE TAPE FORMAT CHANGE ***

	New random number generator.

	Fewer parity symbols:  10 & 14 rather than 16 & 20.

	BKRIOCGETSTATUS will now update the DMA buffer offsets if too much
	time has elapsed since the last update.

	Fixed possible sequence glitch:  need_sequence_reset is now
	explicitly set at the start of each transfer.

	Fixed erroneous over-run reporting when an uncorrectable block is
	found.

	Complete overhaul of the block/sector nonsense.  For starters, the
	new tape format elliminates the auxiliary data region.  With that
	gone, the interleave ratio was increased by a factor of two which
	is how the parity symbols could be safely reduced.  Next, the role
	of data randomizing and ECC encoding/decoding was moved to the
	sector layer.  With ECC done at the sector layer, the sector code
	can now insert and retrieve a header which it uses to store a 32
	bit sector number.  This elliminates the need for block sequence
	numbers which shrinks each block header to just 1 byte thus
	increasing the tape capacity even further.  This also allows more
	bits in the block headers to be used to identify the block type
	which might be used to multiplex several data streams together.
	Since, at 32 bits, the sector number takes about 20000 hours to
	loop around, it provides the data stream with an absolute position
	marker.  This means there is now 100% accuracy in the
	identification of buffer overruns.

1.0 (2001/1/13)
	More performance and foot print improvements to the Reed-Solomon
	code.

	Disabled EP mode until I either get it working or drop it
	altogether.

	Finally got MONITOR.EXE (one of the utilities shipped with a
	Backer) to run under dosemu (sort of).  This allowed me to trace
	I/O port activity and see how Danmere controls the card.  I believe
	I now have the correct sequence in which bits are to be set to
	configure the card for a transfer.  Preliminary tests look good as
	I have not been able to produce any of the inconvenient behaviour
	the card had been showing in the past.

	One or two last minute code clean-ups.

	Gave the documentation a going-over.

0.12(beta) (2000/12/11)
	Fixed a bug in the low level write code:  in the event of an error,
	update_device_offset() was still clearing the update interval timer
	which would prevent retrys from actually retrying.  When propogated
	out to the user's world this bug had the effect of occasionally
	defeating the driver's ability to detect a missing video signal.
	The truth is, though, that this should not have actually had any
	effect.  Hmm....

	Hmm is right!  Checking out how this "bug" managed to manifest
	itself has led me to discover new properties of the hardware.  The
	sync bit on the card's I/O port is actually only for the input
	signal.  This is why the card had appeared to me to be unable to
	generate output without a return signal from the VCR.  It turns out
	that the card can indeed generate output without a return signal.
	I won't go into details but what it boils down to is that in fact
	the "bug" was in my misunderstanding of the function of the sync
	bit.  So we're all happy now.  Although it's no longer necessary,
	the driver still demands that a return video signal be present as a
	check of the data path.

	Solidified error reporting.  The driver had been a little relaxed
	about getting error codes out to the kernel in that it was not
	specifically retaining error codes for the purpose of reporting
	them on a retry but was relying on the error recurring on the
	retry.  Only in the case of an uncorrectable data block can the
	error not occur on the retry and it's unlikely for one
	uncorrectable block to be unacompanied so this wasn't really a
	problem.  Anyway, now the driver makes a point of always returning
	the last error code before proceding.

	Code clean ups.

0.11(beta) (2000/11/26)
	Fixed minor bug in the read and write codes:  in the event of an
	error, the wrong count of actual bytes moved was being returned to
	the system.

	Made a few changes to the formating layer's logic to allow
	non-blocking I/O to take place.  Yes, non-blocking I/O is now
	officially a feature of this driver.  Go ahead and use it and
	report any problems.  My own test has been to write a 50 MB file
	and read it back again with O_NONBLOCK set in both directions.  I
	saw 1.6 million EAGAINs while writing it and 2.8 million EAGAINs
	while reading it but the file was recovered perfectly.

	Code clean ups here and there.

0.10(beta) (2000/11/21)
	Performance improvements to the Reed-Solomon encoder and decoder
	but increased footprint.

	Hardware probe is now only done on write transfers because during
	reads the driver can't tell the difference between missing hardware
	and a mere missing video signal.

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Bug fix: BKRIOCGETAUX and BKRIOCSETAUX now return -ENXIO when the
	sector buffer is not properly allocated.

0.9(beta) (2000/11/16)
	Some documentation updates.

	Serious bug fix:  the auxiliary buffer was not pointing to a safe
	region of memory when the driver was put in raw mode.  This could
	crash your system if you attempted to use bkrtest in raw mode
	(which you ARE supposed to be able to do!).

	Serious bug fix:  if the driver could not allocate memory for its
	buffers during the last mode change and you attempted to read from
	or write to the device then bad things would happen.  This is
	fixed.

	Modified access control.  Superusers can still access the device
	regardless of whether or not it is in use but they are now only
	allowed access to ioctl() if a transfer is in progress.  This
	elliminates a "feature" which allowed superusers to terminate
	another user's transfer (probably leading to problems when that
	user themself's subsequently tried to stop it).

	Lots of code clean ups including low-level device I/O, raw mode
	format layer, data randomizer.

	Added check for presence of hardware at the start of a transfer.  I
	know I said the driver was in a "feature freeze" but after the
	clean ups to the low-level I/O code this was so easy to add I just
	had to do it.

0.8(beta) (2000/11/06)
	First beta release.

	Fixed a bug in the read code which was introduced in the last
	version and was preventing it from returning EOF.

0.7 (2000/11/03)
	Re-worked the I/O code's error reporting mechanism.  Save for any
	bugs that might be discovered in this stuff this now completes the
	system friendliness of the driver.

	Implemented the beginings of non-blocking I/O.  It's actually all
	in there but it's completely untested.  Since tar does not make use
	of non-blocking I/O there's no easy way to put this through its
	paces.  I'm going to have to write a test program.

	Fixed bug in overrun checking code:  the subtraction wasn't being
	done modulo the sequence size.  I hope this didn't cause any
	problems for anyone... 'cause it could have :-(.  It was defeating
	the ability of the driver to skip over underflows during playback.

	If an uncorrectable block is encountered, the driver now removes
	the block from the data stream and returns -ENODATA rather than
	silently pretending that nothing's wrong.

	If an error occurs in the data stream while reading then the block
	sequence counter is now reset.  This keeps the quantity of lost
	data to a minimum.

	Some documentation updates and additions.

0.6 (2000/10/30)
	The driver now checks to see if a video signal is present before
	attempting to proceed with a transfer.  This avoids getting the
	system stuck in a busy loop until the driver times out.

	The device level I/O code will now always go to sleep for a 50th of
	a second between buffer updates rather than switching to a busy
	loop after the first two updates fail.  This keeps the driver from
	plugging up the system before actual tape data starts during a read
	and while flushing the buffer after writing.

	Driver now counts buffer overruns on read.

	Another minor performance improvement to the Reed-Solomon decoder.

0.5 (2000/10/25)
	Implemented an internal sector buffer.  Previously sectors were
	processed in place in the DMA buffer.  I had believed this was
	workable but it now seems that this makes the reliable handling of
	overruns too complicated.  Sectors are now processed in a seperate
	buffer which is transfered to/from the DMA buffer as a whole.  This
	extra copying of data introduces a small increase in the processing
	overhead.

	Added mandatory DMA buffer offset updates if a maximum update delay
	has been exceeded.  I hope that between this and the new sector
	buffer we will handle underflows during writing perfectly
	gracefully.  Preliminary tests look great!  I can force horrible
	buffer underflows during writing by using tar to write directly to
	the device while using bzip2 for compression.  By selecting a small
	record size I can generate many frequent underflows and so far I've
	been able to recover the data without any problems (knock on wood).

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Fixed a bug in the fame error checker:  the maximum search length
	allowed when finding the next key neglected to allow for the
	additional line in odd video fields.

	Minor performance enhancement to the Reed-Solomon decoding
	algorithm.

	Assorted code clean ups.

0.4 (2000/10/20)
	Fixed a bug in the sector locator algorithm which could cause the
	decoder to skip ahead of the incoming tape data.

	Fixed an erasure related buffer overflow in the Reed-Solomon
	decoder but it was not affecting this driver since the driver does
	not make use of erasures.

	Removed "feature" which caused reads to not terminate automatically
	if the tape data simply stopped (eg. without a proper EOR mark):
	ETIMEDOUT is now returned from the block layer rather than
	retrying.

	Improved sanity when switching modes.  Although I'd never had
	troubles myself, while checking the code I felt weird things might
	happen under certain read / close / mode change / open
	combinations.  Definitely all perfect now :-).

	Allowed randomizer to handle odd sized blocks by always allocating
	an even number of bytes for the block buffer.  This wasn't an issue
	yet since the blocks in all current formats have an even number of
	bytes in them.

0.3 (2000/10/17)
	Fixed bug in BKRIOCGETFORMAT ioctl which caused the block capacity
	to be reported as the number of data bytes contained in the current
	block rather than as the design capacity of a block.

	Removed memory access priviledge checks from the read() and write()
	methods --- the kernel (in 2.0.36 at least) checks for us.

	Many documentation improvements.

0.2 (2000/10/10)
	First public release.
