3.101 (2001/12/30)
	*** INCOMPATIBLE TAPE FORMAT CHANGE ***

	Documentation updates.

	Cleaned up the ISA DMA channel search, offset retrieval, and buffer
	flushing algorithms a little bit.

	Made the sector order checking algorithm safe against wrap-around
	then shifted the sector numbering so that the first data sector
	in a recording is sector number 0.

	Did some assorted clean-ups in the formating code.

	Major work on backer_parport.c --- it might even work...

	Removed CONFIG_BACKER_TIMEOUT from the Makefile --- decided it was
	over-design.  The default timeout is now hard-coded in the source.

	Removed the ability to disable various modes at compile time ---
	decided it was over-design.

	Increased the maximum timeout to 1.5 minutes and imposed a minimum
	timeout of 15 seconds to account for the time needed to flush the
	now large I/O buffer.

	Changed the delimiter from ',' to ':' for backer_isa's isa= option
	and removed the restriction on the number of devices that can be
	specified.

	Changed the isa= and port= options in backer_isa and backer_parport
	respectively to units= for both for cross-module consistency.

	Changed the unit locking mechanism from spinlocks to semaphores to
	completely prevent re-entrance in the kernel interface just to be
	on the safe side.

	I *believe* I have finally fixed the off-by-one-line bug in the ISA
	driver!  I can only verify the fix in NTSC mode so the PAL version
	of the fix is a "best guess" but a verification should be
	forth-coming.

	Updated the resource allocation in backer_isa to match current
	kernel practices.

	Moved the format information table from a static array in
	bkr_format.c to an entry in the device info structure.  This is
	done with the intention of eventually allowing each installed
	device to have its own format table (Backers using different video
	field sizes have been observed in the wild).

	Moved the /proc interface from the single /proc/driver/backer file
	to the sysctl hierarchy under /proc/sys/dev/backer.  Each device
	now has a separate subdirectory with its own status file.

	Increased the BOR length to 5 seconds for good luck.

	Added the sysctl interface /proc/sys/dev/backer/*/format_table for
	dynamically loading format tables into the driver.

	Added an I/O wait queue to each unit and elliminated polling from
	the main module.

	Added the poll method;  the driver should now support the select(2)
	and poll(2) system calls.

	Made some minor Reed-Solomon encoder and decoder performance
	improvements.

	Driver now requires a kernel with snprintf().  This function is
	known to be present in 2.4.13 and later kernels.

	Made some changes to the tape format.  Rather than explicitly
	recording the sector type as a field within each sector header, the
	three types of sectors (BOR, DATA and EOR) are identified by the
	sign of the sector number and the amount of data in the sector:
	BOR sectors have negative numbers, EOR sectors are empty, DATA
	sectors are neither of the above.

	Made some more behaviour improvements to the read() and write()
	calls which has also simplified them somewhat.  Most importantly,
	the new semantics guarantee returns to user-space if the data
	stream gets stuck.  This has (mostly) elliminated the need for a
	driver-wide timeout since a hung read or write operation can now be
	killed from outside the kernel.  For this reason, the timeout
	option for the main module along with the timeout-setting ioctl()
	have been removed.  A more significant side effect of the
	improvements, however, is that tar now requires the
	--read-full-blocks option when reading from this driver.

	Changed the "Least Skipped" and "Most Skipped" fields in the status
	interface to "Smallest Field" and "Largest Field" respectively.
	These now indicated the range of video field sizes encountered so
	far during playback.

3.100 (2001/8/15)
	*** INCOMPATIBLE TAPE FORMAT CHANGE ***

	Documentation updates.

	Makefile fixes.

	The randomizer no longer skips the first 4 bytes of each sector.

	Added a secondary buffer to the ISA device layer.  This required
	some modifications to the formating code to support buffer offsets
	that loop at arbitrary powers of two.  The device layer presents
	the (large) secondary buffer to the formating layer while a kernel
	timer shuffles data between the secondary buffer and the real DMA
	buffer.  Currently the secondary buffer's size is set to 512
	kilobytes which allows bzip2 to be used with the driver on a
	PII-400 without buffer underflows!

	Changed "DMA Buffer" to "I/O Buffer" in the /proc interface.

	Increased the number of parity bytes in SP/LP modes from 8 per
	block to 10 for good luck.

	Split the driver's device interface layer off into a separate
	module, backer_isa.o.  The main module, backer.o, provides the
	kernel interface and all data processing functions.  This was done
	in anticipation of adding support for the external version.  As I
	had been planning to do this all along, it required very little in
	the way of changes to the driver's core structure but a LOT of
	typing was required to modify header files, add symbol exporting,
	add module requesting, etc..  The biggest change this induced was
	the replacement of the fixed-size unit array with a dynamic linked
	list of installed units and the code for maintaining it.

	Added a man page for the new backer_isa module.

	Added the skeleton of a module for supporting parallel port devices
	and a man page for it as well.

	Removed module locking for the main module:  handled by kernel's
	filesystem code.

	Added a write-read test to speed up ISA autoprobing.

	Changed the insmod options for ISA devices from ioport=... and
	dma=... to isa=... .

	Re-implemented the driver's ability to start reading before a valid
	data stream is coming off the tape and increased the default
	timeout to 15 seconds (again).

	Removed the reset() function from the device level API.

3.3 (2001/7/5)
	Reworked some code to get rid of a few goto's (yuck).

	Fixed a buffer overflow in the data randomizer.  This bug was also
	causing the randomizer to miss the first 4 bytes of each sector but
	fixing that would be a format change and so will have to wait until
	4.0.  For now, the code emulates the bug-induced format.

	Added some more SMP locking.  Probably not needed but what the
	hell.

	Made all uses of jiffies safe against wrap-around.

	Removed parentheses from around unit state in proc output.

	Removed some unnecessary data initializers to reduce image size.

	Fixed some behaviour for read() and write():  -EAGAIN and -EINTR
	(read) will now only be returned if the "error" occurs before any
	data is transfered otherwise a short count is returned but no other
	action is taken.  Previously, like all other errors, these codes
	were stored and returned on the next call if data had been
	transfered.  (got my hands on some POSIX specifications)

	Increased the minimum DMA buffer update frequency from 3 Hz to 15
	Hz for safer operation in high data rate modes.

	Another POSIX fix for read() and write():  added support for
	O_NDELAY flag.  At this point in history, on all Linux platforms
	except the Sparc64, O_NDELAY implies O_NONBLOCK so this fix is,
	essentially, irrelevant because O_NDELAY behaviour should only
	differ from O_NONBLOCK behaviour when it is specified alone.

	write() will now generate the -EINTR result if a signal arrives
	while it's blocked.  There was a reason it didn't before but I
	can't remember what it was and it seems to work now...

3.2 (2001/6/26)
	Documentation corrections and updates.

	On single CPU machines, the read() and write() methods have been,
	essentially, re-entrance safe since version 2.1 so I elliminated
	the kludgy mechanism for preventing re-entrance.  There can still
	be problems on SMP machines, though, so locking was added to
	properly prevent re-entrance in that case.

	New sector key locator algorithm:  require any n symbols to match
	rather than n in a row.

	Fixed a bug that caused autoprobe routine to release any ioports
	that had been requested by module parameters.  Cleaned the
	autoprobe code up a bit.

	Removed DMA pulse check from transfer start code since that
	functionality is handled by device read/write functions and
	autoprobing.

	Device level stuff now monitors DMA activity via the DMA
	controller's DREQ bit rather than the Backer hardware's DREQ bit.
	A little safer in the event there isn't actually hardware present.

3.1 (2001/6/24)
	*** INCOMPATIBLE TAPE FORMAT CHANGE (EP modes only) ***

	Documentation updates.

	Driver now returns -ENODATA exactly once for each irrecoverable
	sector i.e. sectors for which error correction fails and sectors
	that get overrun.  This has allowed for the creation of the
	bkrenhanced utility.

	With the addition of the bkrenhanced utility, the number of parity
	bytes used by EP modes has been reduced introducing an incompatible
	format change.  I chose to not increase the version major number,
	though, since this only affects EP modes which are to be considered
	experimental anyway.

	Fixed a harmless (yes, really) buffer overflow in the DMA flushing
	routine (only overran the part in use, not the buffer's allocated
	size).

	House-cleaned the header files.

	Replaced tape format parameter computations in backer_fmt.c with a
	look-up table.  A Gnumeric spread sheet has been included in the
	(new) EXTRAS directory for computing the parameters and producing
	valid look-up tables.

	Elliminated the BKRIOCGETFORMAT ioctl.  The information provided by
	that ioctl is now (mostly) available as a look-up table in
	bkr_format.h.

	Added autoprobing and made it the default behaviour.  Hardware
	settings can no longer be compiled in to the driver;  if
	autoprobing does not work, you must specify parameters on the
	insmod command line.

	Fixed an I/O port bug:  the port was not being referenced via the
	device info structure but by the insmod parameter.

	Did some SMP related fixes including fixing a potential power
	management deadlock.

	Fixed a bug in GCR modulation on machines that don't have rolw
	assembly op-code.

	Added multiple device support.  This has changed the format of the
	/proc/driver/backer file by now outputing multiple sets of info,
	one for each device, and with each set having a "Unit" number field
	added to it.

	Changed the semantics of the MTIOCGET ioctl:  the mt_dsreg field
	now always indicates the mode represented by the file on which the
	ioctl is performed rather than the current transfer mode if one is
	occuring on that device.

3.0 (2001/6/2)
	*** INCOMPATIBLE TAPE FORMAT CHANGE ***

	Documentation and Makefile updates.

	Added power management support:  the kernel's power management
	system is kept informed of the driver's active/idle state and the
	driver will not start data transfers between suspend and resume
	requests from the kernel.

	Found and fixed a bug in the init code:  driver would continue to
	load even if the proc interface could not be created.  I decided,
	however, that this was a nice feature so I tidied it up and "added"
	it to the new power management code too.

	Implemented a new tape format.  First, the sector key has been
	removed from the sector data proper and is now handled by the same
	code that inserts the leader, trailer and does the interleaving.
	This allows the key to be optimally interleaved irregardless of the
	interleaving used for the data blocks.  It also means that parity
	is not wasted correcting errors in the key --- the redundancy is
	now applied 100% to data alone.  The second change is the
	completion of a bit stream modulation mechanism which will
	hopefully lead to reasonably reliable EP recording.  1:1 non-return
	to zero (NRZ) modulation is used for SP/LP modes (same as before)
	and an 8:9 (0,4/4) group code record (GCR) modulation is used for
	EP modes.  Thirdly, the sector header was moved to the end of the
	data area so that it doesn't cause quite as much visual "clutter"
	when GCR modulation is used but also for the added benefits of
	simplifying the formating code a bit and keeping the header visible
	on a television set despite its having shrunk following the removal
	of the key sequence.  Fourthly and finally, the header itself has
	been given a tune-up:  by encoding the quantity of data present in
	a truncated sector in such a way that the low four bits are never
	all 0, the 0 value can be used to indicate a non-trucated sector
	thus elliminating the need for a separate flag for that purpose.

	Fixed a bug in the underflow counting logic created by the new
	non-blocking logic introduced in version 2.1:  the underflow_detect
	flag was not being preserved across returns to the kernel interface
	layer causing a single underflow to be recorded as many.

	Implemented stuff that I think makes the driver SMP safe but the
	kernel documentation is, as usual, piss-poor so for all I know I'm
	not even close.  This will, no doubt, evolve.

	The data processing code is now endian and alignment safe.  With
	the exception of possible DMA controller issues, the driver should
	now be portable across all architectures supported by Linux.
	Furthermore, tapes can be shared between computers of different
	endianness.  Tape data processing has been tested by compiling and
	running bkrencode on an IBM RS-6000 running AIX --- the byte
	streams produced could be correctly decoded on an x86.

	Fixed a bug in error reporting:  the number being returned for the
	quantity of data moved prior to the error was potentially incorrect
	although it was correct for non-blocking, -EAGAIN, errors.  The
	solution was to report all errors using the same logic as -EAGAIN.
	I don't know if this is correct semantics.

	Implemented a new sector key locator algorithm.  The new algorithm
	is conceptually simpler and far more robust.  Before, the algorithm
	counted the number of bits that were in agreement and compared that
	to an entropy-based threshold.  Now, the code measures the length
	of the longest run of matching bytes and compares that to a
	likelihood based threshold.

	Changed the behaviour within devfs so that the device files do not
	become the property of the user who has them open but now always
	appear owned by root:root.

2.1 (2001/4/29)
	Documentation updates and corrections.

	Replaced the BKRIOCGETSTATUS ioctl call with a human-readable /proc
	interface allowing the driver's status to be monitored without an
	external helper application.

	Added the early stages of group code record (GCR) bit stream
	modulation to the formating layer.  The actual modulation code is
	currently disabled with #if 0 blocks but the structural changes
	that need to be made before it can be implemented have begun --- so
	ignore all "unused variable" warnings.

	Changed the configuration system a bit.  Rather than having to edit
	paramters in backer_isa.c, all parameters are now located in the
	Makefile so that they can be adjusted from the make command line.
	Just in case someone wanted to make an RPM out of this.

	O_NONBLOCK was not being honoured during read operations until
	after the first valid data sector had been found.  Fixed this by
	moving the logic to skip over the first few bad sectors into the
	formating layer so that it runs in parallel with and can be
	bypassed by the non-blocking logic.  This has the side benefit of
	adding the skip-garbage-at-beginning-of-recording feature to
	anything that uses the formating code (eg. bkrencode).

	Changed the DMA buffer policy during read operations in order to
	achieve some much-needed simplification of the formating code: the
	buffer must now be exactly 64kB in size with the offsets being 16
	bit unsigned ints.  This means that no more explicit checks for
	loop-arounds are required making the read code as simple as the
	write code but it unfortunately requires all other applications
	that make use of the formating code (eg. bkrencode) to play along.

	Overhauled the non-blocking mechanism:  moved all blocking policy
	code from the hardware layer up to the kernel interface layer.
	This required some significant changes to the BOR and EOR
	generation mechanisms and a re-work of the hardware buffer flush
	code.  The consequences of this change are firstly that full
	blocking/non-blocking behaviour is exhibited even when the BOR (and
	eventually the EOR) mark is being written and secondly it fixes a
	busy loop in the formating code that I was never able to track
	down.  It also seems to have reduced the size of the compiled
	binary (?).

	Decided to stop distributing the ``Additional Information''
	document because it accounted for 1/2 of the tar ball and didn't
	really contain any information helpful to users.

2.0 (2001/4/12)
	Changed the flags used to represent the data format to help fix a
	bug in bkrencode.

	Moved the minor numbers around again.  Very sorry!  This was done
	in anticipation of potentially migrating the driver into the main
	kernel tree.  Now each operating mode is assigned a fixed minor
	number --- no more shuffling of minor numbers depending on which
	modes are actually compiled in and which aren't.  If you have been
	using the driver with all modes enabled then you will not see a
	difference.

	Found and fixed a bug in the Makefile's dev target when updating it
	for the new minor numbers.  The modes NTSC/low/raw and NTSC/low/SP
	had their minor numbers backwards.

	If devfs is not in use, the inodes created by the Makefile now have
	the same names as the devfs versions (a tree off /dev).

	Moved more documentation from the postscript file to text files.

	Finally found the cause of the "Unresolved symbol" warnings from
	depmod:  my kernels are compiled with symbol versioning turned on
	so all the symbol names are mangled.  Fixed the problem by
	symbol-versioning the driver.

1.107(beta) (2001/3/24)
	*** INCOMPATIBLE TAPE FORMAT CHANGE ***

	Changed the devfs entry naming scheme.  Rather than dumping
	everything into /dev, a tree structure is created of the form
	/dev/backer/?/??? where the first ? is the device number (currently
	only one device is supported so this is always 0) and the file name
	is three characters:  1st character is n/p for NTSC/PAL, 2nd
	character is h/l for high/low density and last character is e/s/r
	if the file represents an EP/SP/raw mode respectively.  The
	minor-to-mode mapping has also changed.

	Gave the makefile an overhaul:  the install target now checks to
	see if devfs is in use by scanning /proc/mounts and automatically
	creates the device inodes if devfs is not found.

	Re-structured the internal mode flags so that rather than having
	two "formated" modes and one "raw" mode there are three "data
	formats":  sp, ep and raw (pass-through).  This matches the device
	file naming scheme.

	Moved some of the documentation out of the postscript file into
	text files and a man page to be a little more "standard".

	The MTGET ioctl now returns the count of total errors corrected
	since the last read started in the mt_erreg field.

	Adjusted the interleaving and the number of parity symbols in some
	of the tape formats.

	The code is now in feature freeze for 2.0.  Among other things, the
	tape format will not change until the next developmental (pre 3.0)
	series.

1.106 (2001/3/14)
	Fixed bug in transfer start code that would allow a second transfer
	to be started even if one was in progress.

	The "one user only" mechanism has been handed over to devfs's
	internal uid/gid setting feature which means it works a little
	differently:  ownership is done on a device-by-device basis which
	means more than one user can have open devices at a time but all
	except the first will see "Device Busy" if they try to access the
	underlying hardware.

	Removed leader and trailer from bkrformat since nothing's used them
	for a long time.

	High density EP modes will be disabled for version 2.0 and the dev
	target in the makefile has been modified appropriately.  The
	developmental series will retain the EP modes for experimentation,
	however, so the dev target is no longer appropriate for
	developmental versions.

1.105 (2001/3/9)
	*** INCOMPATIBLE FORMAT CHANGE ***

	Added devfs support.

	Added a loop when a read is started to allow the driver to wait as
	long as timeout for a valid sector to appear.  This means that you
	can start reading from the device before the BOR mark is visible on
	your television without getting an I/O error.  The error codes now
	occur as follows:  if no DMA activity is seen before the timeout
	then an I/O error is reported which could mean that you've got the
	driver configured for the wrong DMA channel or that there was no
	video signal on the tape;  if DMA activity is detected but no valid
	data sectors are found before the timeout then a timeout error is
	reported which probably means you've got the right DMA channel but
	the video signal didn't contain anything.

	With the above change in place, I increased the default timeout
	from 10 seconds to 15 seconds to make the driver a little more
	user-friendly.

	Realized that grouping the parity symbols at the end of the sector
	as introduced in 1.104 partially "undid" the interleaving,
	effectively doubling the peak aparent symbol error rate.  The tape
	format has been modified to get the on-tape interleaving back the
	way it used to be.  This is probably the last structural format
	change before 2.0 (but not last parameter change).

	Adjusted the bit allocations in the sector header.

	Rather than falling back to a default mode, open() now fails if the
	minor number is not recognized.

	In raw mode, the transfer unit size is now a full video frame.
	This should improve the throughput since external applications will
	most likely be reading/writing data in quantities commensurate with
	this size.

	Added a fix for a bug in non-comensurate interleaving but it's
	disabled by default to save CPU cycles.

	The usual tweaks here and there.

1.104 (2001/3/4)
	*** INCOMPATIBLE FORMAT CHANGE ***

	read() and write() now lock out other processes to prevent
	re-entrance.

	Separated the device layer code completely from the kernel
	interface.  They're still in one file but share no data.  This was
	done so that bkrencode's source code could be split.

	Cleaned up the sector locator algorithm to work with the new stdio
	device layer for bkrencode.  As a side benefit the compiled code is
	tighter but I'm not sure if the performance has gone up or down.

	Completely new tape format!  There are no longer blocks --- just
	sectors.  This was accomplished by getting the Reed-Solomon
	coder/decoder to handle parity symbols that are stored in a
	separate buffer which allows the formating code to group all the
	parity symbols together in one part of the sector while all the
	data symbols are in another part of the sector.  This removes the
	need to process the sector one block at a time:  all the data
	symbols can be inserted at once, a single sector header added, then
	the parity symbols are computed "block"-by-"block".  The results:
	(i) higher tape capacity (no more block headers);  (ii) longer
	sector key meaning more robust framing;  (iii) less CPU overhead
	due to fewer function calls and loop iterations;  (iv) sector data
	can be selectively randomized meaning we have visual BOR and EOR
	marks again (I've missed these!);  (v) the MTIOCGET reports
	consistent block number and residual counts since these now both
	refer to sectors i.e. the block (sector) number changes every time
	the residual count goes to 0.

	Ported the driver to the 2.4 kernel series which it now requires.
	It might work with 2.2 kernels but if it doesn't then it probably
	wouldn't take much work to get it working.  It will definitely not
	work with 2.0 kernels any more.  There is still no devfs support,
	however.

	Lots of other little changes here and there.

1.103 (2001/2/20)
	*** INCOMPATIBLE FORMAT CHANGE ***

	Changed the leader bytes to 0xe2 like Danmere (maybe they know
	something I don't).

	Fixed a bug in non-comensurate interleaving support:  the driver
	wasn't adjusting the sector header offset for the unused space at
	the start of a sector (no modes use this so it's not an issue).

	Removed block_capacity from bkrformat.  Nothing's used it for
	while.

	Re-allocated bits in the block header structure so that all unused
	bits belong to the block type.  This way future format extensions
	will work with older drivers:  older drivers (from this version on)
	will treat format extensions as unrecognized block types and skip
	them.

	The mt_resid element returned by MTIOCGET now indicates the bytes
	required to fill/empty the current block (it was unused
	previously).

	The operating mode is now selected by the device minor number.
	This means:  (i) there are now 12 requisite entries in the dev
	directory corresponding to the 12 operating modes;  (ii) the
	utility bkrmode no longer exists;  (iii) the config= option has
	been removed with the timeout being set the way it used to be via
	the timeout= option;  (iv) the device is never "not configured"
	since the validity of the operating mode is ensured at the source
	level;  (v) the BKRIOCGETCONFIG and BKRIOCSETCONFIG ioctls are gone
	with the mode now being retrieved only via MTIOCGET (mt_dsreg);
	(vi) adjusting the timeout after module load will have to wait
	until 2.4.x (the required MTSETDRVBUFFER sub-sub-command is not
	present in 2.0.x's mtio.h).

	Fixed another show-stopper pointer initialization bug in
	bkr_format_reset().

1.102 (2001/2/13)
	Formating code now flushes itself after writing an EOR mark.

	The interleave ratio can now be set on a mode-by-mode basis at
	compile time via the format[] parameter array.  Added support for
	non-comensurate interleaving (but it wastes space on the tape so
	it's not recommended).

	Fixed a critical pointer initialization bug in bkr_format_reset()
	and a few other bugs here and there too but can't remember what,
	though.

	Moved the documentation for the utilities into a separate file.

1.101 (2001/2/8)
	This is another major re-write.  Many changes have been made to the
	way the driver interacts with the outside world.

	Implemented a mechanism to delay the start of a data transfer until
	the first I/O operation.

	The delayed start mechanism has removed many race conditions which
	had previously been avoided by imposing unusual access restrictions
	so the entire access control mechanism has been loosened up.  In
	particular:
		-The driver no longer has unusual interpretations of the
		file mode: you can use O_RDONLY/O_WRONLY/O_RDWR as you wish
		and as long as you don't actually call read() or write() no
		transfer will be started (which means the driver now
		behaves itself for mt).
		
		-The device can now be opened multiple times even with a
		direction specified:  the first call to read() or write()
		gives the data stream to that file descriptor and all
		subsequent reads and writes by others fail.
		
		-The device can even be opened by multiple users (but, for
		safety, only if the 2nd and subsequent users are super
		users).
	This should bring the driver's access mechanism in line with
	standard Unix semantics.

	Tracked down and corrected another source of the "start on wrong
	line" syndrom.  It turns out that the card's hardware does not like
	being stopped in the middle of a video frame.  If one takes care to
	always stop writing on a frame boundary then subsequent transfers
	(are more likely to) start on the correct video line.  The fix I
	used was to make bkr_device_flush() fill to a frame boundary before
	flushing the DMA buffer.

	Farther separated the device and formating code.  This has added
	some bloat to the source code but the compiled size has actually
	gone down.  This will increase the ease with which support for the
	external version can be added if I am ever able to get my hands on
	one.

	The mode can now be set at module load time.  It and the timeout
	are now both set with the config= option.  See the docs.

	Obfuscated the Reed-Solomon decoder source code a little with some
	#if-#else-#endif's in order to improve the performace a wee bit
	more.

	Changed the bkrstatus structure.  The "temporary" debuging
	information is now permanent and is grouped together as health
	info.  Anything using BKRIOCGETSTATUS needs to be updated.

	The device layer now monitors the DREQ bit rather than the SYNC
	bit.  This means that the driver no longer cares if a return video
	signal is present (in case you only want to hook up one cable).  It
	also means that stopping a tape while reading from it results in an
	I/O error rather than a timeout.

	Lots of other little touch-ups here and there.

1.100 (2001/1/29)
	*** THIS VERSION INCLUDES AN INCOMPATIBLE TAPE FORMAT CHANGE ***

	New random number generator.

	Fewer parity symbols:  10 & 14 rather than 16 & 20.

	BKRIOCGETSTATUS will now update the DMA buffer offsets if too much
	time has elapsed since the last update.

	Fixed possible sequence glitch:  need_sequence_reset is now
	explicitly set at the start of each transfer.

	Fixed erroneous over-run reporting when an uncorrectable block is
	found.

	Complete overhaul of the block/sector nonsense.  For starters, the
	new tape format elliminates the auxiliary data region.  With that
	gone, the interleave ratio was increased by a factor of two which
	is how the parity symbols could be safely reduced.  Next, the role
	of data randomizing and ECC encoding/decoding was moved to the
	sector layer.  With ECC done at the sector layer, the sector code
	can now insert and retrieve a header which it uses to store a 32
	bit sector number.  This elliminates the need for block sequence
	numbers which shrinks each block header to just 1 byte thus
	increasing the tape capacity even further.  This also allows more
	bits in the block headers to be used to identify the block type
	which might be used to multiplex several data streams together.
	Since, at 32 bits, the sector number takes about 20000 hours to
	loop around, it provides the data stream with an absolute position
	marker.  This means there is now 100% accuracy in the
	identification of buffer overruns.

1.0 (2001/1/13)
	More performance and foot print improvements to the Reed-Solomon
	code.

	Disabled EP mode until I either get it working or drop it
	altogether.

	Finally got MONITOR.EXE (one of the utilities shipped with a
	Backer) to run under dosemu (sort of).  This allowed me to trace
	I/O port activity and see how Danmere controls the card.  I believe
	I now have the correct sequence in which bits are to be set to
	configure the card for a transfer.  Preliminary tests look good as
	I have not been able to produce any of the inconvenient behaviour
	the card had been showing in the past.

	One or two last minute code clean-ups.

	Gave the documentation a going-over.

0.12(beta) (2000/12/11)
	Fixed a bug in the low level write code:  in the event of an error,
	update_device_offset() was still clearing the update interval timer
	which would prevent retrys from actually retrying.  When propogated
	out to the user's world this bug had the effect of occasionally
	defeating the driver's ability to detect a missing video signal.
	The truth is, though, that this should not have actually had any
	effect.  Hmm....

	Hmm is right!  Checking out how this "bug" managed to manifest
	itself has led me to discover new properties of the hardware.  The
	sync bit on the card's I/O port is actually only for the input
	signal.  This is why the card had appeared to me to be unable to
	generate output without a return signal from the VCR.  It turns out
	that the card can indeed generate output without a return signal.
	I won't go into details but what it boils down to is that in fact
	the "bug" was in my misunderstanding of the function of the sync
	bit.  So we're all happy now.  Although it's no longer necessary,
	the driver still demands that a return video signal be present as a
	check of the data path.

	Solidified error reporting.  The driver had been a little relaxed
	about getting error codes out to the kernel in that it was not
	specifically retaining error codes for the purpose of reporting
	them on a retry but was relying on the error recurring on the
	retry.  Only in the case of an uncorrectable data block can the
	error not occur on the retry and it's unlikely for one
	uncorrectable block to be unacompanied so this wasn't really a
	problem.  Anyway, now the driver makes a point of always returning
	the last error code before proceding.

	Code clean ups.

0.11(beta) (2000/11/26)
	Fixed minor bug in the read and write codes:  in the event of an
	error, the wrong count of actual bytes moved was being returned to
	the system.

	Made a few changes to the formating layer's logic to allow
	non-blocking I/O to take place.  Yes, non-blocking I/O is now
	officially a feature of this driver.  Go ahead and use it and
	report any problems.  My own test has been to write a 50 MB file
	and read it back again with O_NONBLOCK set in both directions.  I
	saw 1.6 million EAGAINs while writing it and 2.8 million EAGAINs
	while reading it but the file was recovered perfectly.

	Code clean ups here and there.

0.10(beta) (2000/11/21)
	Performance improvements to the Reed-Solomon encoder and decoder
	but increased footprint.

	Hardware probe is now only done on write transfers because during
	reads the driver can't tell the difference between missing hardware
	and a mere missing video signal.

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Bug fix: BKRIOCGETAUX and BKRIOCSETAUX now return -ENXIO when the
	sector buffer is not properly allocated.

0.9(beta) (2000/11/16)
	Some documentation updates.

	Serious bug fix:  the auxiliary buffer was not pointing to a safe
	region of memory when the driver was put in raw mode.  This could
	crash your system if you attempted to use bkrtest in raw mode
	(which you ARE supposed to be able to do!).

	Serious bug fix:  if the driver could not allocate memory for its
	buffers during the last mode change and you attempted to read from
	or write to the device then bad things would happen.  This is
	fixed.

	Modified access control.  Superusers can still access the device
	regardless of whether or not it is in use but they are now only
	allowed access to ioctl() if a transfer is in progress.  This
	elliminates a "feature" which allowed superusers to terminate
	another user's transfer (probably leading to problems when that
	user themself's subsequently tried to stop it).

	Lots of code clean ups including low-level device I/O, raw mode
	format layer, data randomizer.

	Added check for presence of hardware at the start of a transfer.  I
	know I said the driver was in a "feature freeze" but after the
	clean ups to the low-level I/O code this was so easy to add I just
	had to do it.

0.8(beta) (2000/11/06)
	First beta release.

	Fixed a bug in the read code which was introduced in the last
	version and was preventing it from returning EOF.

0.7 (2000/11/03)
	Re-worked the I/O code's error reporting mechanism.  Save for any
	bugs that might be discovered in this stuff this now completes the
	system friendliness of the driver.

	Implemented the beginings of non-blocking I/O.  It's actually all
	in there but it's completely untested.  Since tar does not make use
	of non-blocking I/O there's no easy way to put this through its
	paces.  I'm going to have to write a test program.

	Fixed bug in overrun checking code:  the subtraction wasn't being
	done modulo the sequence size.  I hope this didn't cause any
	problems for anyone... 'cause it could have :-(.  It was defeating
	the ability of the driver to skip over underflows during playback.

	If an uncorrectable block is encountered, the driver now removes
	the block from the data stream and returns -ENODATA rather than
	silently pretending that nothing's wrong.

	If an error occurs in the data stream while reading then the block
	sequence counter is now reset.  This keeps the quantity of lost
	data to a minimum.

	Some documentation updates and additions.

0.6 (2000/10/30)
	The driver now checks to see if a video signal is present before
	attempting to proceed with a transfer.  This avoids getting the
	system stuck in a busy loop until the driver times out.

	The device level I/O code will now always go to sleep for a 50th of
	a second between buffer updates rather than switching to a busy
	loop after the first two updates fail.  This keeps the driver from
	plugging up the system before actual tape data starts during a read
	and while flushing the buffer after writing.

	Driver now counts buffer overruns on read.

	Another minor performance improvement to the Reed-Solomon decoder.

0.5 (2000/10/25)
	Implemented an internal sector buffer.  Previously sectors were
	processed in place in the DMA buffer.  I had believed this was
	workable but it now seems that this makes the reliable handling of
	overruns too complicated.  Sectors are now processed in a seperate
	buffer which is transfered to/from the DMA buffer as a whole.  This
	extra copying of data introduces a small increase in the processing
	overhead.

	Added mandatory DMA buffer offset updates if a maximum update delay
	has been exceeded.  I hope that between this and the new sector
	buffer we will handle underflows during writing perfectly
	gracefully.  Preliminary tests look great!  I can force horrible
	buffer underflows during writing by using tar to write directly to
	the device while using bzip2 for compression.  By selecting a small
	record size I can generate many frequent underflows and so far I've
	been able to recover the data without any problems (knock on wood).

	Changed the bkrstatus structure.  Any applications retrieving this
	structure via an ioctl must be updated.

	Fixed a bug in the fame error checker:  the maximum search length
	allowed when finding the next key neglected to allow for the
	additional line in odd video fields.

	Minor performance enhancement to the Reed-Solomon decoding
	algorithm.

	Assorted code clean ups.

0.4 (2000/10/20)
	Fixed a bug in the sector locator algorithm which could cause the
	decoder to skip ahead of the incoming tape data.

	Fixed an erasure related buffer overflow in the Reed-Solomon
	decoder but it was not affecting this driver since the driver does
	not make use of erasures.

	Removed "feature" which caused reads to not terminate automatically
	if the tape data simply stopped (eg. without a proper EOR mark):
	ETIMEDOUT is now returned from the block layer rather than
	retrying.

	Improved sanity when switching modes.  Although I'd never had
	troubles myself, while checking the code I felt weird things might
	happen under certain read / close / mode change / open
	combinations.  Definitely all perfect now :-).

	Allowed randomizer to handle odd sized blocks by always allocating
	an even number of bytes for the block buffer.  This wasn't an issue
	yet since the blocks in all current formats have an even number of
	bytes in them.

0.3 (2000/10/17)
	Fixed bug in BKRIOCGETFORMAT ioctl which caused the block capacity
	to be reported as the number of data bytes contained in the current
	block rather than as the design capacity of a block.

	Removed memory access priviledge checks from the read() and write()
	methods --- the kernel (in 2.0.36 at least) checks for us.

	Many documentation improvements.

0.2 (2000/10/10)
	First public release.
