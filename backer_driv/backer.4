.\" Copyright (c) 2001 Kipp Cannon (kcannon@users.sourceforge.net)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.TH Backer 4 "June 2, 2001" "Linux" "Special Files"
.SH NAME
backer \- Backer video tape based storage device.
.SH INTRODUCTION
The Backer device, manufactured by Danmere Technologies Ltd., allows data
to be stored on video tape using a standard video cassette recorder in
either NTSC or PAL video formats.
.SH CONFIGURATION
Under Linux, the Backer hardware is represented by character device files.
By default they are owned by root:root with mode 0666.  They do not have a
standard major number assigned to them but the source is distributed with
60 as the default.  This can be adjusted to the needs of the system.  The
minor number encodes the video mode, bit density and data format.  In
alphabetical order, the device names are:
.PP
.TS
center;
c c.
Name	Minor
_
\fBbacker/\fP\fIn\fP\fB/nhe\fP	0
\fBbacker/\fP\fIn\fP\fB/nhr\fP	1
\fBbacker/\fP\fIn\fP\fB/nhs\fP	2
\fBbacker/\fP\fIn\fP\fB/nle\fP	3
\fBbacker/\fP\fIn\fP\fB/nlr\fP	4
\fBbacker/\fP\fIn\fP\fB/nls\fP	5
\fBbacker/\fP\fIn\fP\fB/phe\fP	6
\fBbacker/\fP\fIn\fP\fB/phr\fP	7
\fBbacker/\fP\fIn\fP\fB/phs\fP	8
\fBbacker/\fP\fIn\fP\fB/ple\fP	9
\fBbacker/\fP\fIn\fP\fB/plr\fP	10
\fBbacker/\fP\fIn\fP\fB/pls\fP	11
.TE
.PP
When used with the device file system, the device files are created
automatically when the driver is loaded.  The \fIn\fP in the path of each
device is the unit number but the driver currently only supports one unit
so this is always 0.  The three letter file name identifies the video mode
(NTSC or PAL), the bit density (high or low), and the data format (SP, EP
or raw) selected by accessing that particular file.
.PP
Depending on how the driver was compiled, some mode combinations might not
be available.  To adjust mode availability, see the \fBbkr_modes[]\fP array
in the sources.
.PP
If the backer device is to be used as the default tape device then it is
helpful to create a symbolic link named \fB/dev/tape\fP that points to the
preferred mode.
.SH DESCRIPTION
.SS GENERAL
The driver presents the Backer device as a set of character device special
files, one for each available format, that try to behave somewhat like tape
devices.  It is not possible to provide a fully functional tape interface
because the tape transport itself (your VCR) is not under computer control.
This means that every task requires operator assistance to complete in that
somebody must manually press Play, Record, Rewind, etc..  Apart from the
lack of automation, however, the driver should be able to inter-operate
with any software designed for use with tape devices such as
.IR mt (1)
and
.IR tar (1).
.PP
The Backer hardware is compatible with both NTSC and PAL video equipment
and it can modulate the data stream into the video signal at two bit
densities, ``high'' and ``low''.  In addition to the hardware settings, one
can also switch the driver software between two tape data formats and a
pass-through mode.  One of the formats is intended for short and long play
(SP/LP) recordings and the other for extended play (EP) recordings while
the pass-through mode by-passes all data processing within the driver
allowing the raw tape data stream to be read and written.  The desired
settings are selected by accessing the appropriate device file but see below
for important information on EP recordings.
.PP
A data transfer is started by making a call to
.IR read (2)
or
.IR write (2)
and stopped by
.IR close (2).
For obvious practical reasons, only one transfer can occur at a time so
once a transfer has been started on a file descriptor, all other reads and
writes on all other descriptors will fail.  Since the hardware is not full
duplex, if a device is opened with mode \fBO_RDWR\fP the first read or
write call selects the transfer direction and any subsequent calls in the
other direction fail.
.PP
Data written to and read from the non-raw files is clean, synchronous and
commensurate:  it will be retrieved error-free (within limits);  the, say,
2000th byte written will be the 2000th byte read back;  and exactly as many
bytes as were written will be played back (the data is not padded to a
multiple of
some size).
.SS "RAW INTERFACE"
The raw device files provide access to the actual tape data.  When writing,
the first byte written is placed in the first position in the top line of
the first video field and so on.  When reading, all the pleasantries of the
raw video signal are present:  tape noise, missing video lines, etc..  The
interface provided by these files allows the requisite tape data processing
to be performed in user space thus not only permitting tapes in formats
foreign to the driver itself to be read and written but also allowing
computers too slow to perform the processing in real time to make use of
higher bandwidth modes.  See
.IR bkrencode (8)
for more information on using this feature.
.SS "STATUS INFORMATION"
Hardware and driver status information is provided through the \fB/proc\fP
file system by the file \fB /proc/driver/backer\fP.  The meaning of each
field in this file is given below and indicated after each field heading is
the transfer direction in which the field is meaningful.  For example, a
field marked ``reading'' does not have meaning during write operations.
Between transfers, all fields will retain their values from the end of the
last transfer.  The information is displayed in unsigned decimal format and
the meaning of the fields is as follows.
.TP
\fBOperating Mode\fP (reading/writing)
A number indicating the video mode, bit density and data format of the
current transfer.  The masks and flags used to interpret this number can be
found in the header file, \fBbacker.h\fP.
.TP
\fBSector Number\fP (reading/writing)
The current sector number being transfered to/from user space.  The DMA
buffer introduces a delay between this and the sector being transfered
to/from the tape.
.TP
\fBTotal Errors Corrected\fP (reading)
Shows the total number of bad symbols that have been successfully corrected
since the current read operation started.
.TP
\fBErrors in Worst Block\fP (reading)
The first field shows the largest number of bad symbols that have been
detected in any one block of data since the current read operation started.
The second field is the number of Reed-Solomon parity symbols in each
block.  If the number of errors in a block exceeds 1/2 the number of parity
symbols then the block cannot be corrected.
.TP
\fBRecent Errors\fP (reading)
Shows the largest number of bad symbols that have been detected in any one
block of data since the last time the \fB/proc\fP file was read.
.TP
\fBUncorrectable Blocks\fP (reading)
The number of blocks which the Reed-Solomon decoder detected could not be
corrected.  Not all uncorrectable blocks can be detected (imagine errors
occurring in such a way that they make the block look like another valid or
correctable block).
.TP
\fBFraming Errors\fP (reading)
An upper bound can be placed on the number of bytes which need to be
searched before a sector key is found and this displays the number of times
this bound was exceeded since the current read operation started.  Framing
errors do not necessarily represent lost data but are symptomatic of a poor
quality recording.
.TP
\fBOverrun Errors\fP (reading)
The number of times the sector sequence number skipped in the positive
direction indicating that the incoming video data filled the DMA buffer and
the computer could not keep up.
.TP
\fBUnderflows Detected\fP (reading)
The number of times the sector sequence number skipped in the negative
direction indicating repeated sectors on the tape.  This indicates that
when the data was written, the computer could not generate it as fast as it
was being sent to tape causing the DMA buffer to empty (and then loop).
Apart from wasting several tens of kilobytes of tape, underflows are
non-destructive.
.TP
\fBWorst Key\fP (reading)
The lowest correlation value assigned to a string of bytes identified as
a sector key.
.TP
\fBClosest Non-Key\fP (reading)
The highest correlation value assigned to a string of bytes identified as
not being a sector key.
.TP
\fBLeast Skipped\fP (reading)
The least number of bytes which were skipped before locating a sector
key.
.TP
\fBMost Skipped\fP (reading)
The most number of bytes which were skipped before locating a sector key.
.TP
\fBDMA Buffer\fP (reading/writing)
The first field shows the number of bytes in the DMA buffer.  The second
field shows the size of the DMA buffer.  Ideally the buffer will be kept
completely full whilst writing and completely empty whilst reading.
.PP
The worst key and closest non-key must have a comfortable margin between
them if one is going to be able to identify sector keys in the data stream.
The difference between the least and most skipped numbers shows the
variability in the number of lines generated by a VCR during playback.
.SH EXAMPLES
The examples below assume that \fB/dev/tape\fP is a link to the desired
device.
.SS "BASIC USE"
To save a file to tape, press Record and type
.RS
.sp
cat \fIfilename\fP > /dev/tape
.sp
.RE
When the recording first starts you will see the beginning-of-record (BOR)
mark which consists of vertical bars and will last for several seconds.
That will be followed by what, for the most part, is random noise until the
recording ends with the end-of-record (EOR) mark.  To verify the recording,
rewind to the beginning (before or during the BOR mark is OK), press Play
and type
.RS
.sp
cmp /dev/tape \fIfilename\fP
.sp
.RE
To retrieve the file, position the tape at the start of the recording as
above and type
.RS
.sp
cat /dev/tape > \fIfilename\fP
.sp
.RE
If the computer isn't fast enough to process the data in real time then
buffer over- and underflows will be seen.  In this case it will be necessary
to use off-line processing.  See
.IR bkrencode (8)
for more information.
.SS "USE WITH tar"
.IR tar (1)
processes data in ``records'' and the larger the record size the more
infrequently tar accesses the device.  If the time that elapses is too
long, then the driver's buffer can underflow (writing) or overflow
(reading).  This is true for all tape devices but due to Backer's
relatively high transfer speed for its buffer size, even tar's default
record size can result in excessive delays if additional processing is
being performed (like compression).  When writing, this is harmless
(although tape is wasted) because the driver can detect the underflow
condition in the data stream during playback and correct it.  When reading,
however, buffer overflows mean data is being lost.
.PP
The default record size for GNU tar is 10 kilobytes (twenty 512-byte
blocks) and on a PII-400 this makes the device accesses too infrequent if
.IR gzip (1)
based compression is used at high data rate.  It appears that the simplest
solution is to set the record size to the minimum of 1 block.  This not
only solves the through-put problem but also seems to result in smaller
archive files.
.PP
The record size is adjusted with the \fB-b\fP option.  An example of
making a backup using
.IR gzip (1)
compression is
.RS
.sp
tar -b 1 -c -z -f /dev/tape [other options...]
.sp
.RE
and the corresponding restore command is
.RS
.sp
tar -b 1 -x -z -f /dev/tape [other options...]
.sp
.RE
.PP
If your computer still has trouble keeping up with the data stream then try
changing the \fB-z\fP to \fB-Z\fP to use
.IR compress (1)
rather than gzip.  The compression will not be as good but there will be
less CPU overhead.  If it still doesn't work try it without any compression
at all.
.SS "MACHINE-TO-MACHINE COPYING"
If two computers with Backers are available then it is possible to use the
Backers to copy data between them.  This is accomplished by cross wiring
the cards (output of ``transmitter'' to input of ``receiver'') then at the
transmitting machine writing data to a device file while at the receiving
machine reading the data from the corresponding device file.  Any of the
non-raw modes can be chosen as long as both machines are speaking the same
one but PAL/high/SP (phs) is recommended since it has the highest code
rate.
.SH IOCTLS
The following
.IR ioctl (2)
calls are understood.
.IP \fBMTIOCTOP\fP
Accepts a pointer to an \fBmtop\fP structure which is used to access
several sub-commands.  The following sub-commands are understood:
.\".RS +0.5i
.RS
.TP
\fBMTNOP\fP
Does nothing.
.TP
\fBMTRESET\fP
Does nothing.
.TP
\fBMTSETDRVBUFFER\fP
With the \fBmt_count\fP field set to (\fBMT_ST_TIMEOUTS\fP | \fItimeout\fP)
the operation timeout is set to \fItimeout\fP seconds.
.RE
.IP \fBMTIOCGET\fP
Accepts a pointer to an \fBmtget\fP structure which is filled with the tape
drive and driver status.  The structure's fields are filled as follows:
.\".RS +0.5i
.RS
.TP
\fBmt_type\fP (drive type)
Set to \fBMT_ISUNKNOWN\fP.
.TP
\fBmt_dsreg\fP (device dependent status bits)
Set to the current mode.  See \fBbacker.h\fP for information on the flags
used for this.  The ``current mode'' is the mode in which the current
transfer is being performed.  This may or may not match the mode
represented by the file on which this ioctl is performed and is not
meaningful unless a transfer is actually taking place.
.TP
\fBmt_gstat\fP (device independent status bits)
The \fBGMT_ONLINE\fP bit is set.
.TP
\fBmt_blkno\fP (block number)
Set to the current sector number.
.TP
\fBmt_resid\fP (residual count)
Set to the number of bytes that need to be transfered in order to
fill/empty the current sector.
.TP
\fBmg_erreg\fP (corrected errors)
Set to the total number of errors that have been corrected since the last
read started.
.TP
\fBmt_fileno\fP (file number)
Not used (set to 0).
.RE
.IP \fBMTIOCPOS\fP
Accepts a pointer to an \fBmtpos\fP structure which is filled with the
current sector number.
.IP \fBBKRIOCGETFORMAT\fP
Accepts a pointer to a \fBbkrformat\fP structure which is filled with
information describing the current format.  This is intended for use with
external applications which wish to interact with the data stream at a
``low level''.  For example,
.IR bkrcheck (8)
needs to know how many bytes to generate in order to get a stable test
pattern on the television screen.
.PP
For the definitions of the structures mentioned above or for more
information generally on these calls see \fBsys/mtio.h\fP and
\fBbacker.h\fP.
.SH ERRORS
The following is a list of the error codes that can be generated by the
driver and the reasons for them.
.IP \fBEAGAIN\fP
.PD 0
.RS +0.5i
.TP 2
o
The current operation would block and non-blocking I/O has been selected.
.RE
.PD 1
.IP \fBEBUSY\fP
.PD 0
.RS +0.5i
.TP 2
o
The I/O port could not be reserved at module load time.
.TP 2
o
An attempt was made to start a transfer or change the direction of a
transfer while one was already in progress.
.TP 2
o
The DMA channel could not be reserved on I/O.
.RE
.PD 1
.IP \fBEINTR\fP
.PD 0
.RS +0.5i
.TP 2
o
A signal arrived while an I/O operation was blocked.
.RE
.PD 1
.IP \fBEINVAL\fP
.PD 0
.RS +0.5i
.TP 2
o
A call was made to
.IR ioctl (2)
with an unrecognized ioctl function or sub-function.
.RE
.PD 1
.IP \fBEIO\fP
.PD 0
.RS +0.5i
.TP 2
o
No DMA activity could be detected during an I/O operation.  Perhaps the
driver is not configured for the correct I/O port or DMA channel or perhaps
the VCR is not connected.
.RE
.PD 1
.IP \fBEISPIPE\fP
.PD 0
.RS +0.5i
.TP 2
o
A call was made to
.IR lseek (2).
The device is not seekable.
.RE
.PD 1
.IP \fBENODATA\fP
.PD 0
.RS +0.5i
.TP 2
o
A data block was read from tape and the Reed-Solomon decoder detected that it
could not correct the errors in it.  The entire sector in which this occurs is
discarded.
.RE
.PD 1
.IP \fBENOMEM\fP
.PD 0
.RS +0.5i
.TP 2
o
The DMA buffer could not be allocated at module load time.
.TP 2
o
Some internal structures could not be allocated on device open.
.TP 2
o
The sector buffer could not be allocated on I/O.
.RE
.PD 1
.IP \fBETIMEDOUT\fP
.PD 0
.RS +0.5i
.TP 2
o
The current operation timed out.
.RE
.PD 1
.SH NOTES
.SS "EP RECORDINGS"
Since version 3.0 of the driver, the data conditioning and processing
algorithms used by the driver have been capable of storing and recovering
data from tapes recorded in EP (extended play) mode.  This is very
experimental work, however, and generally speaking \fBRECORDING DATA IN EP
MODE IS NOT RELIABLE!\fP  Feel free to try it out and see what sort of
performance you get.  I, personally, have been able to store and retrieve
files this way but I would not (yet) use an EP recording for anything
important and it might not work at all on different equipment.
.SS "TAPE CARE"
VCRs are not as gentle with their tapes as data grade transports are
designed to be.  In particular, VCRs have a tendency to stretch tapes when
starting and stopping them.  To improve the reliability of backups, try to
avoid as many start/stop cycles for each tape as reasonably possible.
Especially avoid using the visual search functions of the VCR with any tape
that will be used to store data.
.SH FILES
.IP /dev/backer/*/*
The device file names.
.IP /proc/driver/backer
Driver and hardware status information.
.SH BUGS
Sometimes, when writing to tape, the hardware skips the first line of data
in the DMA buffer.  This shifts the video image up one line and makes it
hard for the driver to stop the card at a proper frame boundary.  The cause
of this is unknown and the tape format is designed to work around the
problem.
.SH "SEE ALSO"
.IR bkrcheck (8),
.IR bkrencode (8),
.IR bkrmonitor (8),
.IR mt (1),
.IR tar (1)
.SH AUTHOR
Kipp Cannon (kcannon@users.sourceforge.net).
.SH AVAILABILITY
The most recent stable and developmental versions of the driver and
utilities can be found on SourceForge at:
.RS
.sp
http://www.sourceforge.net/projects/linbacker
.sp
.RE
.SH HISTORY
.TS
center;
c l c.
Date	Event	Version
_
2000/10/10	First public release	0.2
2001/01/13	First stable release	1.0
2001/04/12	Second stable release	2.0
2001/04/29	Third stable release	2.1
2001/06/02	Fourth stable release	3.0
.TE
